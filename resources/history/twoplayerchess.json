{
  "timestamp": "Tue Mar 02 2021 21:19:56 GMT+0100 (centraleuropeisk normaltid)",
  "results": [
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\chessboard_state\\ChessBoardState.java",
      "result": []
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\chess_pieces\\AbstractChessPiece.java",
      "result": [
        {
          "line": 1,
          "completeString": "White",
          "match": "White",
          "type": "name"
        }
      ]
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\chess_pieces\\Bishop.java",
      "result": [
        {
          "line": 1,
          "completeString": "Bishop",
          "match": "Bishop",
          "type": "name"
        }
      ]
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\chess_pieces\\ChessPieceFactory.java",
      "result": [
        {
          "line": 16,
          "completeString": "Rook",
          "match": "Rook",
          "type": "name"
        },
        {
          "line": 18,
          "completeString": "Knight",
          "match": "Knight",
          "type": "name"
        },
        {
          "line": 20,
          "completeString": "Bishop",
          "match": "Bishop",
          "type": "name"
        },
        {
          "line": 22,
          "completeString": "Queen",
          "match": "Queen",
          "type": "name"
        },
        {
          "line": 24,
          "completeString": "King",
          "match": "King",
          "type": "name"
        },
        {
          "line": 26,
          "completeString": "\\\" is not a valid name of a chess piece class.",
          "match": "not",
          "type": "name"
        },
        {
          "line": 26,
          "completeString": "\\\" is not a valid name of a chess piece class.",
          "match": "name",
          "type": "name"
        },
        {
          "line": 26,
          "completeString": "\\\" is not a valid name of a chess piece class.",
          "match": "chess",
          "type": "name"
        }
      ]
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\chess_pieces\\King.java",
      "result": [
        {
          "line": 1,
          "completeString": "King",
          "match": "King",
          "type": "name"
        }
      ]
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\chess_pieces\\Knight.java",
      "result": [
        {
          "line": 1,
          "completeString": "Knight",
          "match": "Knight",
          "type": "name"
        }
      ]
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\chess_pieces\\Pawn.java",
      "result": []
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\chess_pieces\\Queen.java",
      "result": [
        {
          "line": 1,
          "completeString": "Queen",
          "match": "Queen",
          "type": "name"
        }
      ]
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\chess_pieces\\Rook.java",
      "result": [
        {
          "line": 1,
          "completeString": "Rook",
          "match": "Rook",
          "type": "name"
        }
      ]
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\control\\GameController.java",
      "result": [
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "s",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "an",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "be",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "into",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "an",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "line",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "King",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "an",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "on",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "line",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "p",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "Bishop",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "Rook",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "line",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "king",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "The",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "not",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "add",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s an opposing piece)\n\t\telse {\n\t\t\tfor (List<Position> moveList : initialPossibleMoves) {\n\t\t\t\tfor (Position proposedPosition : moveList) {\n\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition) != null) {\n\t\t\t\t\t\tif (chessBoard.getPieceAtPosition(proposedPosition).getColour()\n\t\t\t\t\t\t\t\t!= gcState.currentPlayerToMove) {\n\t\t\t\t\t\t\t// Are allowed to take pieces of opposite colour.\n\t\t\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// End of the line\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise must be attempting to move into an empty square\n\t\t\t\t\tpossibleMoves.add(proposedPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcullSpecialCases(possibleMoves, clickedPiece);\n\t\treturn possibleMoves;\n\t}\n\n\tpublic List<Position> getAllowedMovesForPiece(AbstractChessPiece chessPiece) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tList<List<Position>> initialPossibleMoves = chessPiece.deriveAllMoves();\n\t\tpossibleMoves = cullIllegalMoves(initialPossibleMoves, chessPiece);\n\t\taddSpecialCases(possibleMoves, chessPiece);\n\t\tassert !possibleMoves.contains(null);\n\t\treturn possibleMoves;\n\t}\n\n\t/*\n\t * Works out the line between the King and the piece. If there is such a line, it sees if\n\t * an opposing piece is on the end of it that would threated the King.\n\t */\n\tprivate List<Position> getCheckedLine(AbstractChessPiece clickedPiece) {\n\t\tKing ownKing = chessBoard.getKing(gcState.currentPlayerToMove);\n\t\tMutableBoolean isDiagonalLine = new MutableBoolean();\n\t\tList<Position> line = calculateSharedOpenLine(ownKing, clickedPiece, isDiagonalLine);\n\t\tif (line == null)\n\t\t\treturn null;\n\t\tfor (Position p : line) {\n\t\t\tAbstractChessPiece threateningPiece = chessBoard.getPieceAtPosition(p);\n\t\t\tif (threateningPiece != null && threateningPiece.getColour() != gcState.currentPlayerToMove) {\n\t\t\t\tif (isDiagonalLine.booleanValue()) {\n\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen)\n\t\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/*\n\t * Calculates the line starting from the king that passes through the king. The line\n\t * continues until it hits a piece of either colour. Does not add the King",
          "match": "King",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "re",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "not",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "on",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "line",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "line",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "may",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "carry",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "on",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "on",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "line",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "not",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "in",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "not",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "on",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "void",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "may",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "re not on a diagonal line.\n\t\tif (xDiff == 0 || yDiff == 0)\n\t\t\tisDiagonalLine.setValue(false);\n\t\telse\n\t\t\tisDiagonalLine.setValue(true);\n\n\t\tif (xDiff > 0)\n\t\t\txInc = 1;\n\t\telse if (xDiff == 0)\n\t\t\txInc = 0;\n\t\telse\n\t\t\txInc = -1;\n\n\t\tif (yDiff > 0)\n\t\t\tyInc = 1;\n\t\telse if (yDiff == 0)\n\t\t\tyInc = 0;\n\t\telse\n\t\t\tyInc = -1;\n\n\t\tboolean passedThroughPieceFlag = false;\n\t\tList<Position> retLine = new ArrayList<Position>();\n\t\tPosition positionToAdd = king.getPosition();\n\t\twhile (true) {\n\t\t\tint xCoord = positionToAdd.getXCoord();\n\t\t\tint yCoord = positionToAdd.getYCoord();\n\t\t\txCoord += xInc;\n\t\t\tyCoord += yInc;\n\t\t\tpositionToAdd = Position.createPosition(xCoord, yCoord);\n\t\t\tif (positionToAdd == null) {\n\t\t\t\t// Break if the line is now extending off the board\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretLine.add(positionToAdd);\n\n\t\t\t// Once the line has passed through the piece, it may carry on until it hits another piece\n\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != null) {\n\t\t\t\tif (passedThroughPieceFlag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (chessBoard.getPieceAtPosition(positionToAdd) != piece) {\n\t\t\t\t\t// If the first piece on the line is not the piece in question, then the piece\n\t\t\t\t\t// does not lie on a checked line.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tpassedThroughPieceFlag = true;\n\t\t\t}\n\t\t}\n\t\treturn retLine;\n\t}\n\n\tprivate List<Position> addPositionsOnCheckedLine(List<List<Position>> initialPossibleMoves,\n\t\t\tList<Position> checkedLine) {\n\t\tList<Position> possibleMoves = new ArrayList<Position>();\n\t\tfor (List<Position> positionList : initialPossibleMoves) {\n\t\t\tfor (Position position : positionList) {\n\t\t\t\tif (checkedLine.contains(position)) {\n\t\t\t\t\tpossibleMoves.add(position);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn possibleMoves;\n\t}\n\n\tprivate void cullSpecialCases(List<Position> possibleMoves,\n\t\t\tAbstractChessPiece clickedPiece) {\n\t\tPosition clickedPiecePosition = clickedPiece.getPosition();\n\t\tSet<Position> positionsToDelete = new HashSet<Position>();\n\t\tif (clickedPiece instanceof Pawn) {\n\t\t\t// Potentially take away its forward move(s)\n\t\t\tint forwardMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? 1 : -1;\n\n\t\t\tPosition forwardPosition = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition);\n\t\t\t\t// Cannot move forward two spaces if the space ahead is checked.\n\t\t\t\tpositionsToDelete.add(Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove));\n\t\t\t}\n\n\t\t\t// If the first space ahead is free, may still need to cull the second space ahead.\n\t\t\tPosition forwardPosition2 = Position.createPosition(clickedPiecePosition.getXCoord(),\n\t\t\t\t\tclickedPiecePosition.getYCoord() + 2 * forwardMove);\n\t\t\tif (chessBoard.getPieceAtPosition(forwardPosition2) != null) {\n\t\t\t\tpositionsToDelete.add(forwardPosition2);\n\t\t\t}\n\n\t\t\t// Potentially take away forward-diagonal moves\n\t\t\tfor (int xDisp = -1; xDisp < 2; xDisp += 2) {\n\t\t\t\tPosition forwardDiagonal = Position.createPosition(clickedPiecePosition.getXCoord() + xDisp,\n\t\t\t\t\t\tclickedPiecePosition.getYCoord() + forwardMove);\n\t\t\t\tAbstractChessPiece potentialVictim = chessBoard.getPieceAtPosition(forwardDiagonal);\n\t\t\t\tif (potentialVictim == null || potentialVictim.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\tpositionsToDelete.add(forwardDiagonal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Don",
          "match": "Don",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s a checkmate.\n\t * If the king can",
          "match": "s",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s a checkmate.\n\t * If the king can",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s a checkmate.\n\t * If the king can",
          "match": "king",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s a checkmate.\n\t * If the king can",
          "match": "can",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s more than one threatening line, it",
          "match": "s",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s more than one threatening line, it",
          "match": "than",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s more than one threatening line, it",
          "match": "one",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s just one\n\t * threatening line, each piece on the board will have to be called to see if it can\n\t * move onto the line (the line being squares including the attacking piece",
          "match": "s",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s just one\n\t * threatening line, each piece on the board will have to be called to see if it can\n\t * move onto the line (the line being squares including the attacking piece",
          "match": "on",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s just one\n\t * threatening line, each piece on the board will have to be called to see if it can\n\t * move onto the line (the line being squares including the attacking piece",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s just one\n\t * threatening line, each piece on the board will have to be called to see if it can\n\t * move onto the line (the line being squares including the attacking piece",
          "match": "will",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s just one\n\t * threatening line, each piece on the board will have to be called to see if it can\n\t * move onto the line (the line being squares including the attacking piece",
          "match": "be",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s just one\n\t * threatening line, each piece on the board will have to be called to see if it can\n\t * move onto the line (the line being squares including the attacking piece",
          "match": "see",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s just one\n\t * threatening line, each piece on the board will have to be called to see if it can\n\t * move onto the line (the line being squares including the attacking piece",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s just one\n\t * threatening line, each piece on the board will have to be called to see if it can\n\t * move onto the line (the line being squares including the attacking piece",
          "match": "line",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s just one\n\t * threatening line, each piece on the board will have to be called to see if it can\n\t * move onto the line (the line being squares including the attacking piece",
          "match": "line",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s just one\n\t * threatening line, each piece on the board will have to be called to see if it can\n\t * move onto the line (the line being squares including the attacking piece",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s checkmate.\n\t * Note: A threatening line includes a pawn that",
          "match": "s",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s checkmate.\n\t * Note: A threatening line includes a pawn that",
          "match": "line",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "t",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "King",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "be",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "he",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "he",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "will",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "be",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "into",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "he",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "be",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "in",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "An",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "Rook",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "king",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "in",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "King",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "king",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "he",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "be",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "in",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "line",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "Rook",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "King",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "be",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "Bishop",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "King",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "logic",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "not",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t want the friendly King to be seen as blocking\n\t\t\t\t\t * check at a position. Because if he is, then he will be allowed to move into it, but\n\t\t\t\t\t * he would still be in check following that move.\n\t\t\t\t\t *\n\t\t\t\t\t * An example is if a Rook has put the king in check. Without\n\t\t\t\t\t * temporarily making the King invisible here, the program would allow the king to move sideways\n\t\t\t\t\t * yet he would still be in check following this move.\n\t\t\t\t\t */\n\t\t\t\t\tif (threateningPiece == null ||\n\t\t\t\t\t\t\t(threateningPiece.getColour() == gcState.getCurrentPlayerToMove() && threateningPiece instanceof King)) {\n\t\t\t\t\t\t// continue following the line\n\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (threateningPiece.getColour() == gcState.currentPlayerToMove) {\n\t\t\t\t\t\t// End of line is a friendly piece\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If a vertical/horizontal line\n\t\t\t\t\tif (xDisp == 0 || yDisp == 0) {\n\t\t\t\t\t\tif (threateningPiece instanceof Rook || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t|| Math.abs(position.getYCoord() - y) == 1))) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// must be a diagonal line\n\t\t\t\t\t\tif (threateningPiece instanceof Bishop || threateningPiece instanceof Queen\n\t\t\t\t\t\t\t\t|| (threateningPiece instanceof King && (Math.abs(position.getXCoord() - x) == 1\n\t\t\t\t\t\t\t\t&& Math.abs(position.getYCoord() - y) == 1))\n\t\t\t\t\t\t\t\t|| threateningPiece instanceof Pawn && isThreateningPawn((Pawn)threateningPiece, position)) {\n\t\t\t\t\t\t\tline.add(nextPosition);\n\t\t\t\t\t\t\tlistHolder.add(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn listHolder;\n\t}\n\n\t/*\n\t * Short piece of logic called from getThreateningLines. Have already established that the\n\t * pawn is the opposite colour to the current player.\n\t */\n\tprivate boolean isThreateningPawn(\n\t\t\tPawn pawn, Position position) {\n\t\tPosition pawnPosition = pawn.getPosition();\n\t\tint xDiff = pawnPosition.getXCoord() - position.getXCoord();\n\t\tint yDiff = pawnPosition.getYCoord() - position.getYCoord();\n\t\t// If the pawn is not directly diagonal, it can",
          "match": "can",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s\n\t\tList<AbstractChessPiece> currentPlayersPieces = chessBoard.getPlayersPieces(gcState.currentPlayerToMove);\n\t\tfor (AbstractChessPiece chessPiece : currentPlayersPieces) {\n\t\t\tif (chessPiece instanceof King)\n\t\t\t\t// King cannot block the check of himself.\n\t\t\t\tcontinue;\n\t\t\tList<Position> allowedMoves = getAllowedMovesForPiece(chessPiece);\n\n\t\t\tfor (Position checkBlockingMove : gcState.checkBlockingMoves) {\n\t\t\t\tif (allowedMoves.contains(checkBlockingMove)) {\n\t\t\t\t\t// It",
          "match": "King",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s\n\t\tList<AbstractChessPiece> currentPlayersPieces = chessBoard.getPlayersPieces(gcState.currentPlayerToMove);\n\t\tfor (AbstractChessPiece chessPiece : currentPlayersPieces) {\n\t\t\tif (chessPiece instanceof King)\n\t\t\t\t// King cannot block the check of himself.\n\t\t\t\tcontinue;\n\t\t\tList<Position> allowedMoves = getAllowedMovesForPiece(chessPiece);\n\n\t\t\tfor (Position checkBlockingMove : gcState.checkBlockingMoves) {\n\t\t\t\tif (allowedMoves.contains(checkBlockingMove)) {\n\t\t\t\t\t// It",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t immutable.\n\t\t\t\tduplicateArrayList(gcState.checkBlockingMoves),\n\t\t\t\tgcState.currentPlayerIsInCheck,\n\t\t\t\tgcState.enPassantPosition,\n\t\t\t\tgcState.moveNumber);\n\n\t\treturn new ChessBoardMoment(chessPieces, castlingOpportunities,\n\t\t\t\tcastlingPiecesMovementTracker, clonedGCState);\n\t}\n\n\tprivate CastlingOpportunities constructCastlingOpportunities() {\n\t\tBoolean[] castlingOpportunitiesArray = new Boolean[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcastlingOpportunitiesArray[i] = false;\n\t\t}\n\t\tint counter = 0;\n\n\t\t// Temporarily change gcState.getCurrentPlayerToMove() back to what it was\n\t\tgcState.currentPlayerToMove = (gcState.currentPlayerToMove == Colour.WHITE) ? Colour.BLACK : Colour.WHITE;\n\n\t\tfor (int yCoord = 1; yCoord <= 8; yCoord += 7) {\n\t\t\t// gcState.getCurrentPlayerToMove() has already been changed to be the opposite colour\n\t\t\tif (gcState.getCurrentPlayerToMove() == Colour.WHITE && yCoord == 8\n\t\t\t\t\t|| gcState.getCurrentPlayerToMove() == Colour.BLACK && yCoord == 1) {\n\t\t\t\tcastlingOpportunitiesArray[counter] = null;\n\t\t\t\tcounter++;\n\t\t\t\tcastlingOpportunitiesArray[counter] = null;\n\t\t\t\tcounter++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPosition reqKingPosition = Position.createPosition(King.KING_POS, yCoord);\n\t\t\tAbstractChessPiece supposedKing = chessBoard.getPieceAtPosition(reqKingPosition);\n\t\t\tif (!(supposedKing instanceof King)\n\t\t\t\t\t|| (supposedKing != null && supposedKing.hasMoved())) {\n\t\t\t\tcounter += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int direction = -1; direction < 2; direction += 2, counter++) {\n\t\t\t\tPosition rookPosition = Position.createPosition((direction == -1) ? 1 : 8,\n\t\t\t\t\t\tyCoord);\n\t\t\t\tif (canCastleBetweenPositions(reqKingPosition, rookPosition, direction)) {\n\t\t\t\t\tcastlingOpportunitiesArray[counter] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Put it back to what it was before\n\t\tgcState.currentPlayerToMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? Colour.BLACK : Colour.WHITE;\n\n\t\treturn new CastlingOpportunities(castlingOpportunitiesArray[0], castlingOpportunitiesArray[1], castlingOpportunitiesArray[3], castlingOpportunitiesArray[2]);\n\t}\n\n\tprivate boolean canCastleBetweenPositions(Position kingPosition, Position rookPosition, int direction) {\n\t\tAbstractChessPiece potentialRook = chessBoard.getPieceAtPosition(rookPosition);\n\t\t// Can",
          "match": "t",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t immutable.\n\t\t\t\tduplicateArrayList(gcState.checkBlockingMoves),\n\t\t\t\tgcState.currentPlayerIsInCheck,\n\t\t\t\tgcState.enPassantPosition,\n\t\t\t\tgcState.moveNumber);\n\n\t\treturn new ChessBoardMoment(chessPieces, castlingOpportunities,\n\t\t\t\tcastlingPiecesMovementTracker, clonedGCState);\n\t}\n\n\tprivate CastlingOpportunities constructCastlingOpportunities() {\n\t\tBoolean[] castlingOpportunitiesArray = new Boolean[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcastlingOpportunitiesArray[i] = false;\n\t\t}\n\t\tint counter = 0;\n\n\t\t// Temporarily change gcState.getCurrentPlayerToMove() back to what it was\n\t\tgcState.currentPlayerToMove = (gcState.currentPlayerToMove == Colour.WHITE) ? Colour.BLACK : Colour.WHITE;\n\n\t\tfor (int yCoord = 1; yCoord <= 8; yCoord += 7) {\n\t\t\t// gcState.getCurrentPlayerToMove() has already been changed to be the opposite colour\n\t\t\tif (gcState.getCurrentPlayerToMove() == Colour.WHITE && yCoord == 8\n\t\t\t\t\t|| gcState.getCurrentPlayerToMove() == Colour.BLACK && yCoord == 1) {\n\t\t\t\tcastlingOpportunitiesArray[counter] = null;\n\t\t\t\tcounter++;\n\t\t\t\tcastlingOpportunitiesArray[counter] = null;\n\t\t\t\tcounter++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPosition reqKingPosition = Position.createPosition(King.KING_POS, yCoord);\n\t\t\tAbstractChessPiece supposedKing = chessBoard.getPieceAtPosition(reqKingPosition);\n\t\t\tif (!(supposedKing instanceof King)\n\t\t\t\t\t|| (supposedKing != null && supposedKing.hasMoved())) {\n\t\t\t\tcounter += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int direction = -1; direction < 2; direction += 2, counter++) {\n\t\t\t\tPosition rookPosition = Position.createPosition((direction == -1) ? 1 : 8,\n\t\t\t\t\t\tyCoord);\n\t\t\t\tif (canCastleBetweenPositions(reqKingPosition, rookPosition, direction)) {\n\t\t\t\t\tcastlingOpportunitiesArray[counter] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Put it back to what it was before\n\t\tgcState.currentPlayerToMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? Colour.BLACK : Colour.WHITE;\n\n\t\treturn new CastlingOpportunities(castlingOpportunitiesArray[0], castlingOpportunitiesArray[1], castlingOpportunitiesArray[3], castlingOpportunitiesArray[2]);\n\t}\n\n\tprivate boolean canCastleBetweenPositions(Position kingPosition, Position rookPosition, int direction) {\n\t\tAbstractChessPiece potentialRook = chessBoard.getPieceAtPosition(rookPosition);\n\t\t// Can",
          "match": "be",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t immutable.\n\t\t\t\tduplicateArrayList(gcState.checkBlockingMoves),\n\t\t\t\tgcState.currentPlayerIsInCheck,\n\t\t\t\tgcState.enPassantPosition,\n\t\t\t\tgcState.moveNumber);\n\n\t\treturn new ChessBoardMoment(chessPieces, castlingOpportunities,\n\t\t\t\tcastlingPiecesMovementTracker, clonedGCState);\n\t}\n\n\tprivate CastlingOpportunities constructCastlingOpportunities() {\n\t\tBoolean[] castlingOpportunitiesArray = new Boolean[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcastlingOpportunitiesArray[i] = false;\n\t\t}\n\t\tint counter = 0;\n\n\t\t// Temporarily change gcState.getCurrentPlayerToMove() back to what it was\n\t\tgcState.currentPlayerToMove = (gcState.currentPlayerToMove == Colour.WHITE) ? Colour.BLACK : Colour.WHITE;\n\n\t\tfor (int yCoord = 1; yCoord <= 8; yCoord += 7) {\n\t\t\t// gcState.getCurrentPlayerToMove() has already been changed to be the opposite colour\n\t\t\tif (gcState.getCurrentPlayerToMove() == Colour.WHITE && yCoord == 8\n\t\t\t\t\t|| gcState.getCurrentPlayerToMove() == Colour.BLACK && yCoord == 1) {\n\t\t\t\tcastlingOpportunitiesArray[counter] = null;\n\t\t\t\tcounter++;\n\t\t\t\tcastlingOpportunitiesArray[counter] = null;\n\t\t\t\tcounter++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPosition reqKingPosition = Position.createPosition(King.KING_POS, yCoord);\n\t\t\tAbstractChessPiece supposedKing = chessBoard.getPieceAtPosition(reqKingPosition);\n\t\t\tif (!(supposedKing instanceof King)\n\t\t\t\t\t|| (supposedKing != null && supposedKing.hasMoved())) {\n\t\t\t\tcounter += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int direction = -1; direction < 2; direction += 2, counter++) {\n\t\t\t\tPosition rookPosition = Position.createPosition((direction == -1) ? 1 : 8,\n\t\t\t\t\t\tyCoord);\n\t\t\t\tif (canCastleBetweenPositions(reqKingPosition, rookPosition, direction)) {\n\t\t\t\t\tcastlingOpportunitiesArray[counter] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Put it back to what it was before\n\t\tgcState.currentPlayerToMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? Colour.BLACK : Colour.WHITE;\n\n\t\treturn new CastlingOpportunities(castlingOpportunitiesArray[0], castlingOpportunitiesArray[1], castlingOpportunitiesArray[3], castlingOpportunitiesArray[2]);\n\t}\n\n\tprivate boolean canCastleBetweenPositions(Position kingPosition, Position rookPosition, int direction) {\n\t\tAbstractChessPiece potentialRook = chessBoard.getPieceAtPosition(rookPosition);\n\t\t// Can",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "t immutable.\n\t\t\t\tduplicateArrayList(gcState.checkBlockingMoves),\n\t\t\t\tgcState.currentPlayerIsInCheck,\n\t\t\t\tgcState.enPassantPosition,\n\t\t\t\tgcState.moveNumber);\n\n\t\treturn new ChessBoardMoment(chessPieces, castlingOpportunities,\n\t\t\t\tcastlingPiecesMovementTracker, clonedGCState);\n\t}\n\n\tprivate CastlingOpportunities constructCastlingOpportunities() {\n\t\tBoolean[] castlingOpportunitiesArray = new Boolean[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcastlingOpportunitiesArray[i] = false;\n\t\t}\n\t\tint counter = 0;\n\n\t\t// Temporarily change gcState.getCurrentPlayerToMove() back to what it was\n\t\tgcState.currentPlayerToMove = (gcState.currentPlayerToMove == Colour.WHITE) ? Colour.BLACK : Colour.WHITE;\n\n\t\tfor (int yCoord = 1; yCoord <= 8; yCoord += 7) {\n\t\t\t// gcState.getCurrentPlayerToMove() has already been changed to be the opposite colour\n\t\t\tif (gcState.getCurrentPlayerToMove() == Colour.WHITE && yCoord == 8\n\t\t\t\t\t|| gcState.getCurrentPlayerToMove() == Colour.BLACK && yCoord == 1) {\n\t\t\t\tcastlingOpportunitiesArray[counter] = null;\n\t\t\t\tcounter++;\n\t\t\t\tcastlingOpportunitiesArray[counter] = null;\n\t\t\t\tcounter++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tPosition reqKingPosition = Position.createPosition(King.KING_POS, yCoord);\n\t\t\tAbstractChessPiece supposedKing = chessBoard.getPieceAtPosition(reqKingPosition);\n\t\t\tif (!(supposedKing instanceof King)\n\t\t\t\t\t|| (supposedKing != null && supposedKing.hasMoved())) {\n\t\t\t\tcounter += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int direction = -1; direction < 2; direction += 2, counter++) {\n\t\t\t\tPosition rookPosition = Position.createPosition((direction == -1) ? 1 : 8,\n\t\t\t\t\t\tyCoord);\n\t\t\t\tif (canCastleBetweenPositions(reqKingPosition, rookPosition, direction)) {\n\t\t\t\t\tcastlingOpportunitiesArray[counter] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Put it back to what it was before\n\t\tgcState.currentPlayerToMove = (gcState.getCurrentPlayerToMove() == Colour.WHITE) ? Colour.BLACK : Colour.WHITE;\n\n\t\treturn new CastlingOpportunities(castlingOpportunitiesArray[0], castlingOpportunitiesArray[1], castlingOpportunitiesArray[3], castlingOpportunitiesArray[2]);\n\t}\n\n\tprivate boolean canCastleBetweenPositions(Position kingPosition, Position rookPosition, int direction) {\n\t\tAbstractChessPiece potentialRook = chessBoard.getPieceAtPosition(rookPosition);\n\t\t// Can",
          "match": "Can",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s already moved.\n\t\tif (potentialRook == null || !(potentialRook instanceof Rook) || potentialRook.hasMoved())\n\t\t\treturn false;\n\t\t// Check that the two squares adjacent to the King are empty and unchecked\n\t\tfor (int i = 1; i < 3; i++) {\n\t\t\tPosition nextSquare = Position.createPosition(King.KING_POS + i * direction,\n\t\t\t\t\trookPosition.getYCoord());\n\t\t\tif (chessBoard.getPieceAtPosition(nextSquare) != null || positionIsChecked(nextSquare))\n\t\t\t\treturn false;\n\t\t}\n\t\t// Positions (2, 1) and (2, 8) must be empty but may be checked.\n\t\tif (direction == -1 &&\n\t\t\t\tchessBoard.getPieceAtPosition(Position.createPosition(2, rookPosition.getYCoord())) != null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate CastlingPiecesMovementTracker constructCastlingPiecesMovementTracker() {\n\t\tboolean[] inputs = new boolean[6];\n\t\tint counter = 0;\n\t\tfor (int yCoord = 1; yCoord <= 8; yCoord += 7) {\n\t\t\tfor (int xCoord = 1; xCoord != 12; xCoord += 4, counter++) {\n\t\t\t\t// Really I just want to do for xCoord in 1 5 8\n\t\t\t\tif (xCoord == 9)\n\t\t\t\t\txCoord = 8;\n\t\t\t\tString requiredPiece = (xCoord == 5) ? \"King\" : \"Rook\";\n\t\t\t\tPosition position = Position.createPosition(xCoord, yCoord);\n\t\t\t\tAbstractChessPiece pieceAtPosition = chessBoard.getPieceAtPosition(position);\n\t\t\t\tif (pieceAtPosition != null && pieceAtPosition.getName().contains(requiredPiece)\n\t\t\t\t\t\t&& !pieceAtPosition.hasMoved())\n\t\t\t\t\tinputs[counter] = true;\n\t\t\t}\n\t\t}\n\t\treturn new CastlingPiecesMovementTracker(inputs);\n\t}\n\n\t/**\n\t * TODO This shouldn",
          "match": "s",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s already moved.\n\t\tif (potentialRook == null || !(potentialRook instanceof Rook) || potentialRook.hasMoved())\n\t\t\treturn false;\n\t\t// Check that the two squares adjacent to the King are empty and unchecked\n\t\tfor (int i = 1; i < 3; i++) {\n\t\t\tPosition nextSquare = Position.createPosition(King.KING_POS + i * direction,\n\t\t\t\t\trookPosition.getYCoord());\n\t\t\tif (chessBoard.getPieceAtPosition(nextSquare) != null || positionIsChecked(nextSquare))\n\t\t\t\treturn false;\n\t\t}\n\t\t// Positions (2, 1) and (2, 8) must be empty but may be checked.\n\t\tif (direction == -1 &&\n\t\t\t\tchessBoard.getPieceAtPosition(Position.createPosition(2, rookPosition.getYCoord())) != null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate CastlingPiecesMovementTracker constructCastlingPiecesMovementTracker() {\n\t\tboolean[] inputs = new boolean[6];\n\t\tint counter = 0;\n\t\tfor (int yCoord = 1; yCoord <= 8; yCoord += 7) {\n\t\t\tfor (int xCoord = 1; xCoord != 12; xCoord += 4, counter++) {\n\t\t\t\t// Really I just want to do for xCoord in 1 5 8\n\t\t\t\tif (xCoord == 9)\n\t\t\t\t\txCoord = 8;\n\t\t\t\tString requiredPiece = (xCoord == 5) ? \"King\" : \"Rook\";\n\t\t\t\tPosition position = Position.createPosition(xCoord, yCoord);\n\t\t\t\tAbstractChessPiece pieceAtPosition = chessBoard.getPieceAtPosition(position);\n\t\t\t\tif (pieceAtPosition != null && pieceAtPosition.getName().contains(requiredPiece)\n\t\t\t\t\t\t&& !pieceAtPosition.hasMoved())\n\t\t\t\t\tinputs[counter] = true;\n\t\t\t}\n\t\t}\n\t\treturn new CastlingPiecesMovementTracker(inputs);\n\t}\n\n\t/**\n\t * TODO This shouldn",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s already moved.\n\t\tif (potentialRook == null || !(potentialRook instanceof Rook) || potentialRook.hasMoved())\n\t\t\treturn false;\n\t\t// Check that the two squares adjacent to the King are empty and unchecked\n\t\tfor (int i = 1; i < 3; i++) {\n\t\t\tPosition nextSquare = Position.createPosition(King.KING_POS + i * direction,\n\t\t\t\t\trookPosition.getYCoord());\n\t\t\tif (chessBoard.getPieceAtPosition(nextSquare) != null || positionIsChecked(nextSquare))\n\t\t\t\treturn false;\n\t\t}\n\t\t// Positions (2, 1) and (2, 8) must be empty but may be checked.\n\t\tif (direction == -1 &&\n\t\t\t\tchessBoard.getPieceAtPosition(Position.createPosition(2, rookPosition.getYCoord())) != null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate CastlingPiecesMovementTracker constructCastlingPiecesMovementTracker() {\n\t\tboolean[] inputs = new boolean[6];\n\t\tint counter = 0;\n\t\tfor (int yCoord = 1; yCoord <= 8; yCoord += 7) {\n\t\t\tfor (int xCoord = 1; xCoord != 12; xCoord += 4, counter++) {\n\t\t\t\t// Really I just want to do for xCoord in 1 5 8\n\t\t\t\tif (xCoord == 9)\n\t\t\t\t\txCoord = 8;\n\t\t\t\tString requiredPiece = (xCoord == 5) ? \"King\" : \"Rook\";\n\t\t\t\tPosition position = Position.createPosition(xCoord, yCoord);\n\t\t\t\tAbstractChessPiece pieceAtPosition = chessBoard.getPieceAtPosition(position);\n\t\t\t\tif (pieceAtPosition != null && pieceAtPosition.getName().contains(requiredPiece)\n\t\t\t\t\t\t&& !pieceAtPosition.hasMoved())\n\t\t\t\t\tinputs[counter] = true;\n\t\t\t}\n\t\t}\n\t\treturn new CastlingPiecesMovementTracker(inputs);\n\t}\n\n\t/**\n\t * TODO This shouldn",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s already moved.\n\t\tif (potentialRook == null || !(potentialRook instanceof Rook) || potentialRook.hasMoved())\n\t\t\treturn false;\n\t\t// Check that the two squares adjacent to the King are empty and unchecked\n\t\tfor (int i = 1; i < 3; i++) {\n\t\t\tPosition nextSquare = Position.createPosition(King.KING_POS + i * direction,\n\t\t\t\t\trookPosition.getYCoord());\n\t\t\tif (chessBoard.getPieceAtPosition(nextSquare) != null || positionIsChecked(nextSquare))\n\t\t\t\treturn false;\n\t\t}\n\t\t// Positions (2, 1) and (2, 8) must be empty but may be checked.\n\t\tif (direction == -1 &&\n\t\t\t\tchessBoard.getPieceAtPosition(Position.createPosition(2, rookPosition.getYCoord())) != null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate CastlingPiecesMovementTracker constructCastlingPiecesMovementTracker() {\n\t\tboolean[] inputs = new boolean[6];\n\t\tint counter = 0;\n\t\tfor (int yCoord = 1; yCoord <= 8; yCoord += 7) {\n\t\t\tfor (int xCoord = 1; xCoord != 12; xCoord += 4, counter++) {\n\t\t\t\t// Really I just want to do for xCoord in 1 5 8\n\t\t\t\tif (xCoord == 9)\n\t\t\t\t\txCoord = 8;\n\t\t\t\tString requiredPiece = (xCoord == 5) ? \"King\" : \"Rook\";\n\t\t\t\tPosition position = Position.createPosition(xCoord, yCoord);\n\t\t\t\tAbstractChessPiece pieceAtPosition = chessBoard.getPieceAtPosition(position);\n\t\t\t\tif (pieceAtPosition != null && pieceAtPosition.getName().contains(requiredPiece)\n\t\t\t\t\t\t&& !pieceAtPosition.hasMoved())\n\t\t\t\t\tinputs[counter] = true;\n\t\t\t}\n\t\t}\n\t\treturn new CastlingPiecesMovementTracker(inputs);\n\t}\n\n\t/**\n\t * TODO This shouldn",
          "match": "King",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s already moved.\n\t\tif (potentialRook == null || !(potentialRook instanceof Rook) || potentialRook.hasMoved())\n\t\t\treturn false;\n\t\t// Check that the two squares adjacent to the King are empty and unchecked\n\t\tfor (int i = 1; i < 3; i++) {\n\t\t\tPosition nextSquare = Position.createPosition(King.KING_POS + i * direction,\n\t\t\t\t\trookPosition.getYCoord());\n\t\t\tif (chessBoard.getPieceAtPosition(nextSquare) != null || positionIsChecked(nextSquare))\n\t\t\t\treturn false;\n\t\t}\n\t\t// Positions (2, 1) and (2, 8) must be empty but may be checked.\n\t\tif (direction == -1 &&\n\t\t\t\tchessBoard.getPieceAtPosition(Position.createPosition(2, rookPosition.getYCoord())) != null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate CastlingPiecesMovementTracker constructCastlingPiecesMovementTracker() {\n\t\tboolean[] inputs = new boolean[6];\n\t\tint counter = 0;\n\t\tfor (int yCoord = 1; yCoord <= 8; yCoord += 7) {\n\t\t\tfor (int xCoord = 1; xCoord != 12; xCoord += 4, counter++) {\n\t\t\t\t// Really I just want to do for xCoord in 1 5 8\n\t\t\t\tif (xCoord == 9)\n\t\t\t\t\txCoord = 8;\n\t\t\t\tString requiredPiece = (xCoord == 5) ? \"King\" : \"Rook\";\n\t\t\t\tPosition position = Position.createPosition(xCoord, yCoord);\n\t\t\t\tAbstractChessPiece pieceAtPosition = chessBoard.getPieceAtPosition(position);\n\t\t\t\tif (pieceAtPosition != null && pieceAtPosition.getName().contains(requiredPiece)\n\t\t\t\t\t\t&& !pieceAtPosition.hasMoved())\n\t\t\t\t\tinputs[counter] = true;\n\t\t\t}\n\t\t}\n\t\treturn new CastlingPiecesMovementTracker(inputs);\n\t}\n\n\t/**\n\t * TODO This shouldn",
          "match": "be",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s already moved.\n\t\tif (potentialRook == null || !(potentialRook instanceof Rook) || potentialRook.hasMoved())\n\t\t\treturn false;\n\t\t// Check that the two squares adjacent to the King are empty and unchecked\n\t\tfor (int i = 1; i < 3; i++) {\n\t\t\tPosition nextSquare = Position.createPosition(King.KING_POS + i * direction,\n\t\t\t\t\trookPosition.getYCoord());\n\t\t\tif (chessBoard.getPieceAtPosition(nextSquare) != null || positionIsChecked(nextSquare))\n\t\t\t\treturn false;\n\t\t}\n\t\t// Positions (2, 1) and (2, 8) must be empty but may be checked.\n\t\tif (direction == -1 &&\n\t\t\t\tchessBoard.getPieceAtPosition(Position.createPosition(2, rookPosition.getYCoord())) != null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate CastlingPiecesMovementTracker constructCastlingPiecesMovementTracker() {\n\t\tboolean[] inputs = new boolean[6];\n\t\tint counter = 0;\n\t\tfor (int yCoord = 1; yCoord <= 8; yCoord += 7) {\n\t\t\tfor (int xCoord = 1; xCoord != 12; xCoord += 4, counter++) {\n\t\t\t\t// Really I just want to do for xCoord in 1 5 8\n\t\t\t\tif (xCoord == 9)\n\t\t\t\t\txCoord = 8;\n\t\t\t\tString requiredPiece = (xCoord == 5) ? \"King\" : \"Rook\";\n\t\t\t\tPosition position = Position.createPosition(xCoord, yCoord);\n\t\t\t\tAbstractChessPiece pieceAtPosition = chessBoard.getPieceAtPosition(position);\n\t\t\t\tif (pieceAtPosition != null && pieceAtPosition.getName().contains(requiredPiece)\n\t\t\t\t\t\t&& !pieceAtPosition.hasMoved())\n\t\t\t\t\tinputs[counter] = true;\n\t\t\t}\n\t\t}\n\t\treturn new CastlingPiecesMovementTracker(inputs);\n\t}\n\n\t/**\n\t * TODO This shouldn",
          "match": "may",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s already moved.\n\t\tif (potentialRook == null || !(potentialRook instanceof Rook) || potentialRook.hasMoved())\n\t\t\treturn false;\n\t\t// Check that the two squares adjacent to the King are empty and unchecked\n\t\tfor (int i = 1; i < 3; i++) {\n\t\t\tPosition nextSquare = Position.createPosition(King.KING_POS + i * direction,\n\t\t\t\t\trookPosition.getYCoord());\n\t\t\tif (chessBoard.getPieceAtPosition(nextSquare) != null || positionIsChecked(nextSquare))\n\t\t\t\treturn false;\n\t\t}\n\t\t// Positions (2, 1) and (2, 8) must be empty but may be checked.\n\t\tif (direction == -1 &&\n\t\t\t\tchessBoard.getPieceAtPosition(Position.createPosition(2, rookPosition.getYCoord())) != null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate CastlingPiecesMovementTracker constructCastlingPiecesMovementTracker() {\n\t\tboolean[] inputs = new boolean[6];\n\t\tint counter = 0;\n\t\tfor (int yCoord = 1; yCoord <= 8; yCoord += 7) {\n\t\t\tfor (int xCoord = 1; xCoord != 12; xCoord += 4, counter++) {\n\t\t\t\t// Really I just want to do for xCoord in 1 5 8\n\t\t\t\tif (xCoord == 9)\n\t\t\t\t\txCoord = 8;\n\t\t\t\tString requiredPiece = (xCoord == 5) ? \"King\" : \"Rook\";\n\t\t\t\tPosition position = Position.createPosition(xCoord, yCoord);\n\t\t\t\tAbstractChessPiece pieceAtPosition = chessBoard.getPieceAtPosition(position);\n\t\t\t\tif (pieceAtPosition != null && pieceAtPosition.getName().contains(requiredPiece)\n\t\t\t\t\t\t&& !pieceAtPosition.hasMoved())\n\t\t\t\t\tinputs[counter] = true;\n\t\t\t}\n\t\t}\n\t\treturn new CastlingPiecesMovementTracker(inputs);\n\t}\n\n\t/**\n\t * TODO This shouldn",
          "match": "be",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s already moved.\n\t\tif (potentialRook == null || !(potentialRook instanceof Rook) || potentialRook.hasMoved())\n\t\t\treturn false;\n\t\t// Check that the two squares adjacent to the King are empty and unchecked\n\t\tfor (int i = 1; i < 3; i++) {\n\t\t\tPosition nextSquare = Position.createPosition(King.KING_POS + i * direction,\n\t\t\t\t\trookPosition.getYCoord());\n\t\t\tif (chessBoard.getPieceAtPosition(nextSquare) != null || positionIsChecked(nextSquare))\n\t\t\t\treturn false;\n\t\t}\n\t\t// Positions (2, 1) and (2, 8) must be empty but may be checked.\n\t\tif (direction == -1 &&\n\t\t\t\tchessBoard.getPieceAtPosition(Position.createPosition(2, rookPosition.getYCoord())) != null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate CastlingPiecesMovementTracker constructCastlingPiecesMovementTracker() {\n\t\tboolean[] inputs = new boolean[6];\n\t\tint counter = 0;\n\t\tfor (int yCoord = 1; yCoord <= 8; yCoord += 7) {\n\t\t\tfor (int xCoord = 1; xCoord != 12; xCoord += 4, counter++) {\n\t\t\t\t// Really I just want to do for xCoord in 1 5 8\n\t\t\t\tif (xCoord == 9)\n\t\t\t\t\txCoord = 8;\n\t\t\t\tString requiredPiece = (xCoord == 5) ? \"King\" : \"Rook\";\n\t\t\t\tPosition position = Position.createPosition(xCoord, yCoord);\n\t\t\t\tAbstractChessPiece pieceAtPosition = chessBoard.getPieceAtPosition(position);\n\t\t\t\tif (pieceAtPosition != null && pieceAtPosition.getName().contains(requiredPiece)\n\t\t\t\t\t\t&& !pieceAtPosition.hasMoved())\n\t\t\t\t\tinputs[counter] = true;\n\t\t\t}\n\t\t}\n\t\treturn new CastlingPiecesMovementTracker(inputs);\n\t}\n\n\t/**\n\t * TODO This shouldn",
          "match": "do",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s already moved.\n\t\tif (potentialRook == null || !(potentialRook instanceof Rook) || potentialRook.hasMoved())\n\t\t\treturn false;\n\t\t// Check that the two squares adjacent to the King are empty and unchecked\n\t\tfor (int i = 1; i < 3; i++) {\n\t\t\tPosition nextSquare = Position.createPosition(King.KING_POS + i * direction,\n\t\t\t\t\trookPosition.getYCoord());\n\t\t\tif (chessBoard.getPieceAtPosition(nextSquare) != null || positionIsChecked(nextSquare))\n\t\t\t\treturn false;\n\t\t}\n\t\t// Positions (2, 1) and (2, 8) must be empty but may be checked.\n\t\tif (direction == -1 &&\n\t\t\t\tchessBoard.getPieceAtPosition(Position.createPosition(2, rookPosition.getYCoord())) != null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate CastlingPiecesMovementTracker constructCastlingPiecesMovementTracker() {\n\t\tboolean[] inputs = new boolean[6];\n\t\tint counter = 0;\n\t\tfor (int yCoord = 1; yCoord <= 8; yCoord += 7) {\n\t\t\tfor (int xCoord = 1; xCoord != 12; xCoord += 4, counter++) {\n\t\t\t\t// Really I just want to do for xCoord in 1 5 8\n\t\t\t\tif (xCoord == 9)\n\t\t\t\t\txCoord = 8;\n\t\t\t\tString requiredPiece = (xCoord == 5) ? \"King\" : \"Rook\";\n\t\t\t\tPosition position = Position.createPosition(xCoord, yCoord);\n\t\t\t\tAbstractChessPiece pieceAtPosition = chessBoard.getPieceAtPosition(position);\n\t\t\t\tif (pieceAtPosition != null && pieceAtPosition.getName().contains(requiredPiece)\n\t\t\t\t\t\t&& !pieceAtPosition.hasMoved())\n\t\t\t\t\tinputs[counter] = true;\n\t\t\t}\n\t\t}\n\t\treturn new CastlingPiecesMovementTracker(inputs);\n\t}\n\n\t/**\n\t * TODO This shouldn",
          "match": "for",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s already moved.\n\t\tif (potentialRook == null || !(potentialRook instanceof Rook) || potentialRook.hasMoved())\n\t\t\treturn false;\n\t\t// Check that the two squares adjacent to the King are empty and unchecked\n\t\tfor (int i = 1; i < 3; i++) {\n\t\t\tPosition nextSquare = Position.createPosition(King.KING_POS + i * direction,\n\t\t\t\t\trookPosition.getYCoord());\n\t\t\tif (chessBoard.getPieceAtPosition(nextSquare) != null || positionIsChecked(nextSquare))\n\t\t\t\treturn false;\n\t\t}\n\t\t// Positions (2, 1) and (2, 8) must be empty but may be checked.\n\t\tif (direction == -1 &&\n\t\t\t\tchessBoard.getPieceAtPosition(Position.createPosition(2, rookPosition.getYCoord())) != null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate CastlingPiecesMovementTracker constructCastlingPiecesMovementTracker() {\n\t\tboolean[] inputs = new boolean[6];\n\t\tint counter = 0;\n\t\tfor (int yCoord = 1; yCoord <= 8; yCoord += 7) {\n\t\t\tfor (int xCoord = 1; xCoord != 12; xCoord += 4, counter++) {\n\t\t\t\t// Really I just want to do for xCoord in 1 5 8\n\t\t\t\tif (xCoord == 9)\n\t\t\t\t\txCoord = 8;\n\t\t\t\tString requiredPiece = (xCoord == 5) ? \"King\" : \"Rook\";\n\t\t\t\tPosition position = Position.createPosition(xCoord, yCoord);\n\t\t\t\tAbstractChessPiece pieceAtPosition = chessBoard.getPieceAtPosition(position);\n\t\t\t\tif (pieceAtPosition != null && pieceAtPosition.getName().contains(requiredPiece)\n\t\t\t\t\t\t&& !pieceAtPosition.hasMoved())\n\t\t\t\t\tinputs[counter] = true;\n\t\t\t}\n\t\t}\n\t\treturn new CastlingPiecesMovementTracker(inputs);\n\t}\n\n\t/**\n\t * TODO This shouldn",
          "match": "in",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "s already moved.\n\t\tif (potentialRook == null || !(potentialRook instanceof Rook) || potentialRook.hasMoved())\n\t\t\treturn false;\n\t\t// Check that the two squares adjacent to the King are empty and unchecked\n\t\tfor (int i = 1; i < 3; i++) {\n\t\t\tPosition nextSquare = Position.createPosition(King.KING_POS + i * direction,\n\t\t\t\t\trookPosition.getYCoord());\n\t\t\tif (chessBoard.getPieceAtPosition(nextSquare) != null || positionIsChecked(nextSquare))\n\t\t\t\treturn false;\n\t\t}\n\t\t// Positions (2, 1) and (2, 8) must be empty but may be checked.\n\t\tif (direction == -1 &&\n\t\t\t\tchessBoard.getPieceAtPosition(Position.createPosition(2, rookPosition.getYCoord())) != null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate CastlingPiecesMovementTracker constructCastlingPiecesMovementTracker() {\n\t\tboolean[] inputs = new boolean[6];\n\t\tint counter = 0;\n\t\tfor (int yCoord = 1; yCoord <= 8; yCoord += 7) {\n\t\t\tfor (int xCoord = 1; xCoord != 12; xCoord += 4, counter++) {\n\t\t\t\t// Really I just want to do for xCoord in 1 5 8\n\t\t\t\tif (xCoord == 9)\n\t\t\t\t\txCoord = 8;\n\t\t\t\tString requiredPiece = (xCoord == 5) ? \"King\" : \"Rook\";\n\t\t\t\tPosition position = Position.createPosition(xCoord, yCoord);\n\t\t\t\tAbstractChessPiece pieceAtPosition = chessBoard.getPieceAtPosition(position);\n\t\t\t\tif (pieceAtPosition != null && pieceAtPosition.getName().contains(requiredPiece)\n\t\t\t\t\t\t&& !pieceAtPosition.hasMoved())\n\t\t\t\t\tinputs[counter] = true;\n\t\t\t}\n\t\t}\n\t\treturn new CastlingPiecesMovementTracker(inputs);\n\t}\n\n\t/**\n\t * TODO This shouldn",
          "match": "TODO",
          "type": "name"
        }
      ]
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\control\\GameControllerStateInfo.java",
      "result": []
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\gui\\ChessBoard.java",
      "result": [
        {
          "line": 1,
          "completeString": "Two player chess",
          "match": "chess",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "gray",
          "match": "gray",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "white",
          "match": "white",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Rook",
          "match": "Rook",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Knight",
          "match": "Knight",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Bishop",
          "match": "Bishop",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Queen",
          "match": "Queen",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "King",
          "match": "King",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "inIcon should not be null.",
          "match": "not",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "inIcon should not be null.",
          "match": "be",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Error: Could not locate \\\"",
          "match": "not",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": ".gif\\\" in the current folder.",
          "match": "in",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": ".gif\\\" in the current folder.",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "There should always be a king of either colour",
          "match": "be",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "There should always be a king of either colour",
          "match": "king",
          "type": "name"
        }
      ]
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\gui\\EndGame.java",
      "result": [
        {
          "line": 1,
          "completeString": "White has checkmated Black.",
          "match": "White",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": " has no moves available, so the game ends in stalemate.",
          "match": "no",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": " has no moves available, so the game ends in stalemate.",
          "match": "so",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": " has no moves available, so the game ends in stalemate.",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": " has no moves available, so the game ends in stalemate.",
          "match": "in",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Neither player has the pieces required to achieve checkmate, ",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "so the game ends in stalemate.",
          "match": "so",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "so the game ends in stalemate.",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "so the game ends in stalemate.",
          "match": "in",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "This exact board position, with the same moves ",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "This exact board position, with the same moves ",
          "match": "same",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "available, has occurred three times in a row. ",
          "match": "in",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Fifty moves have taken place without any pieces ",
          "match": "any",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "being taken, or a pawn being moved. ",
          "match": "or",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": " may declare stalemate.",
          "match": "may",
          "type": "name"
        }
      ]
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\gui\\PawnReplacementChoice.java",
      "result": [
        {
          "line": 1,
          "completeString": "Bishop",
          "match": "Bishop",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Knight",
          "match": "Knight",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Queen",
          "match": "Queen",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Rook",
          "match": "Rook",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Choose a piece to replace the pawn.",
          "match": "the",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Queen",
          "match": "Queen",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Queen",
          "match": "Queen",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Knight",
          "match": "Knight",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Knight",
          "match": "Knight",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Rook",
          "match": "Rook",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Rook",
          "match": "Rook",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Bishop",
          "match": "Bishop",
          "type": "name"
        },
        {
          "line": 1,
          "completeString": "Bishop",
          "match": "Bishop",
          "type": "name"
        }
      ]
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\stalemate\\CastlingOpportunities.java",
      "result": []
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\stalemate\\CastlingPiecesMovementTracker.java",
      "result": []
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\stalemate\\ChessBoardMoment.java",
      "result": []
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\stalemate\\StalemateChecker.java",
      "result": []
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\undo_redo\\UndoRedoInformation.java",
      "result": []
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\undo_redo\\UndoRedoMove.java",
      "result": []
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\util\\MutableBoolean.java",
      "result": []
    },
    {
      "absolutePath": "C:\\Users\\xabba\\Desktop\\School_History\\twoplayerchess-code\\src\\util\\Position.java",
      "result": []
    }
  ]
}